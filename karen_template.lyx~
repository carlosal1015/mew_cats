#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass amsbook
\begin_preamble
\definecolor{darklinkcolor}{rgb}{0,0,0.7}
\definecolor{darkcitecolor}{rgb}{0.4,0,0}
\definecolor{greylabel}{rgb}{0.8,0.8,0.8}
\definecolor{softblue}{rgb}{0.3,0.6,0.8}
\definecolor{softgreen}{rgb}{0.3,0.6,0.5}
\definecolor{sagecolor}{rgb}{0.329411764705882, 0.321568627450980, 0.243137254901961}
%\definecolor{sagecolor}{rgb}{0.470588235294118, 0.458823529411765, 0.345098039215686}
%\definecolor{sagecolor}{rgb}{0.611764705882353, 0.600000000000000, 0.450980392156863}
%\definecolor{sagecolor}{rgb}{0.737254901960784, 0.721568627450980, 0.541176470588235}
%\definecolor{sagecolor}{rgb}{0.815686274509804, 0.807843137254902, 0.682352941176471}
%\definecolor{sagecolor}{rgb}{0.925490196078431, 0.921568627450980, 0.874509803921569}
\definecolor{sageerrorcolor}{rgb}{0.8,0,0}
\definecolor{keyboardcolor}{rgb}{0.3,0.3,0.3}

\newcommand\lacol{\color{greylabel}}

\newcommand\sageinput[1]{%
\hangindent=2.8em\texttt{\textcolor{blue}{sage:}}\texttt{\ #1}%
}
\newcommand\sagemoreinput[1]{%
\hangindent=2.8em\texttt{\textcolor{blue}{\ \ \ \ \ }}\texttt{\ #1}%
}
\newcommand\sageoutput[1]{%
\texttt{\textcolor{blue}{#1}}%
}
\newcommand\sageerror[1]{%
\texttt{\textcolor{sageerrorcolor}{#1}}%
}
\newcommand\sageindent{\texttt{\ \hspace{4em}}}
\newcommand\pseudocodestatement[1]{%
{\ #1}%
}
\end_preamble
\use_default_options true
\begin_removed_modules
eqs-within-sections
figs-within-sections
\end_removed_modules
\begin_modules
theorems-ams
theorems-ams-extended
algorithm2e
theorems-named
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 49
Style SageInteraction
BottomSep	1
Category	"Sage Interaction"
InPreamble	1
KeepEmpty	1
LabelFont
Color	Blue
EndFont
LabelString	"Sage Interaction"
LabelBottomSep	-1
LabelType	Centered
LatexName	sageinteraction
LatexType	Environment
LeftMargin	"Sage Interaction"
Preamble
\usepackage{framed}
\newenvironment{sageinteraction}%
{\begin{center}\begin{minipage}[t]{0.8\columnwidth}%
%\definecolor{shadecolor}{rgb}{0.9,0.9,1.0}%
%\definecolor{shadecolor}{rgb}{0.734375,0.71875,0.5390625}%
%\definecolor{shadecolor}{rgb}{0.8156862745,0.807843,0.6823529}%
%\definecolor{shadecolor}{rgb}{0.854901960784314, 0.843137254901961, 0.745098039215686}
\definecolor{shadecolor}{rgb}{0.890196078431372, 0.882352941176471, 0.807843137254902}
\begin{shaded}}%
{\end{shaded}\end{minipage}\end{center}}
EndPreamble
RightMargin	"MMMM"
Spellcheck	False
TopSep	0.5
End
 
Style SageInput
Align	Left
Category	"Sage Interaction"
LabelFont
Family	Typewriter
Color	Blue
EndFont
LabelSep	"M"
LabelString	"sage: "
LabelType	Static
LatexName	sageinput
LatexType	Command
Argument	1
MenuString	"Input text"
Mandatory	1
Font
Family	Typewriter
Color	Black
EndFont
AutoInsert	1
EndArgument
LeftMargin	"MMsage:"
Spellcheck	False
TextFont
Color	Black
Family	Typewriter
EndFont
End

Style SageMoreInput
Align	Left
Category	"Sage Interaction"
LabelFont
Family	Typewriter
Color	Blue
EndFont
LabelSep	"M"
LabelString	"sage: "
LabelType	Static
LatexName	sagemoreinput
LatexType	Command
Argument	1
MenuString	"Input text"
Mandatory	1
Font
Family	Typewriter
Color	Black
EndFont
AutoInsert	1
EndArgument
LeftMargin	"MMsage:"
Spellcheck	False
TextFont
Color	Black
Family	Typewriter
EndFont
End

Style SageOutput
Align	Left
Category	"Sage Interaction"
LabelFont
Family	Roman
Color	Black
Shape	Italic
EndFont
LabelSep	"M"
LabelString	"output:"
LabelType	Static
LatexName	sageoutput
LatexType	Command
Argument	1
MenuString	"Output text"
Mandatory	1
AutoInsert	1
EndArgument
LeftMargin	"output:"
Spellcheck	False
TextFont
Color	Blue
Family	Typewriter
EndFont
End

Style SageError
Align	Left
Category	"Sage Interaction"
LabelFont
Family	Roman
Color	Red
Shape	Italic
EndFont
LabelSep	"M"
LabelString	"error:"
LabelType	Static
LatexName	sageerror
LatexType	Command
Argument	1
MenuString	"Error text"
Mandatory	1
AutoInsert	1
EndArgument
LeftMargin	"error:"
Spellcheck	False
TextFont
Color	Red
Family	Typewriter
EndFont
End

Style Pseudocode
BottomSep	1
Category	"Pseudocode"
InPreamble	1
KeepEmpty	1
LabelFont
Color	Blue
EndFont
LabelString	"Pseudocode"
LabelBottomSep	-1
LabelType	Centered
LatexName	pseudocode
LatexType	Environment
LeftMargin	"Pseudocode"
Preamble
\usepackage{framed}
\newenvironment{pseudocode}%
{\begin{center}\begin{minipage}[t]{0.8\columnwidth}%
\definecolor{shadecolor}{rgb}{0.9,0.9,1.0}
%\definecolor{shadecolor}{rgb}{0.734375,0.71875,0.5390625}%
\begin{shaded}}%
{\end{shaded}\end{minipage}\end{center}}
EndPreamble
RightMargin	"MMMM"
Spellcheck	False
TopSep	0.5
End

InsetLayout "Flex:Sage Word"
LyxType	custom
LatexType	command
LatexName	sageword
LabelString	"sage word"
Font
Color	Green
Family	Typewriter
EndFont
Preamble
\newcommand\sageword[1]{{\texttt{\color{sagecolor}#1}}}
EndPreamble
Spellcheck	0
ContentAsLabel	1
ForcePlain	1
MultiPar	0
End

InsetLayout "Flex:Keyboard Press"
LyxType	custom
LatexType	command
LatexName	keyboardpress
LabelString	"kbd"
Font
Family	Typewriter
EndFont
Preamble
\newcommand\keyboardpress[1]{{\texttt{\color{keyboardcolor}#1}}}
EndPreamble
Spellcheck	0
ContentAsLabel	1
ForcePlain	1
MultiPar	0
End

InsetLayout "Flex:Sage Constant"
LyxType	custom
LatexType	command
LatexName	sageconstant
LabelString	"sage cons"
Font
Color	Green
Family	Typewriter
Shape	Italic
EndFont
Preamble
\newcommand\sageconstant[1]{{\texttt{\textit{\color{sagecolor}#1}}}}
EndPreamble
Spellcheck	0
ContentAsLabel	1
ForcePlain	1
MultiPar	0
End

InsetLayout "Flex:Boolean Constant"
LyxType	custom
LatexType	command
LatexName	boolconstant
LabelString	"bool const"
Font
Color	Green
Family	Roman
Shape	Italic
EndFont
Preamble
\newcommand\boolconstant[1]{{\textit{#1}}}
EndPreamble
Spellcheck	0
ContentAsLabel	1
ForcePlain	1
MultiPar	0
End
\end_local_layout
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman md-garamond
\font_sans uop
\font_typewriter beramono
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex -c
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=darklinkcolor,urlcolor=darklinkcolor,citecolor=darkcitecolor,naturalnames=true,hypertexnames=false"
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Peering into Advanced Mathematics through Sage-colored Glasses
\end_layout

\begin_layout Author
John Harris,
\begin_inset Newline newline
\end_inset

Karen Kohl, and
\begin_inset Newline newline
\end_inset

John Perry,
\begin_inset Newline newline
\end_inset

all employed at the University of Southern Mississippi
\begin_inset Newline newline
\end_inset

(at least until the Provost's Office reads this debacle)
\end_layout

\begin_layout Thanks
\align block
This work was supported in part by a Summer Grant for the Improvement for
 Instruction, awarded by the Office of the Provost at the University of
 Southern Mississippi.
 We would also like to thank William Stein and the Sage developers for moral
 support and occasional financial support to Sage Days workshops.
 All the developers who have contributed to the Sage project, whether directly
 or indirectly, deserve the scientific community's profound gratitude, though
 we can only assure them of ours.
 Finally (stop applauding, it's rude) two of us have spouses and children
 that deserve apologies more than thanks, but since textbooks don't typically
 have a special section for apologies, we thank them instead.
\end_layout

\begin_layout Subjectclass
97U30, 97N80
\end_layout

\begin_layout Chapter*
A template for Karen
\end_layout

\begin_layout Standard
Dear Karen,
\end_layout

\begin_layout Standard
By now you probably know that Lyx lets you create inline math by pressing
 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Ctrl+M
\end_layout

\end_inset

 and display math by pressing 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Ctrl+Shift+M
\end_layout

\end_inset

.
 There's some other stuff in the User's Guide (see the 
\begin_inset Quotes eld
\end_inset

Help
\begin_inset Quotes erd
\end_inset

 menu) that tells you how to do various things, though a lot of it is menu-drive
n.
\end_layout

\begin_layout Standard
For this text, I created some special layouts to help format things nicely
 & consistently, especially if there are changes.
 Please try to use them if you can.
 They are:
\end_layout

\begin_layout Itemize
The Sage interaction layout.
 You get this by going to the style menu (a drop-down menu at the top-left
 of the window), clicking on it, typing 
\begin_inset Quotes eld
\end_inset

sage
\begin_inset Quotes erd
\end_inset

, then selecting 
\begin_inset Quotes eld
\end_inset

Sage interaction.
\begin_inset Quotes erd
\end_inset

 You don't actually have to type 
\begin_inset Quotes eld
\end_inset

sage
\begin_inset Quotes erd
\end_inset

 but I find that easier that scrolling through the menu.
\end_layout

\begin_layout Itemize
The Sage input layout.
 Similar.
 You typically have to hit 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Tab
\end_layout

\end_inset

 after selecting this, as Sage doesn't automatically place it under the
 Sage interaction.
 Maybe one day I'll figure out how to do that, but probably not, because
 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Tab
\end_layout

\end_inset

 isn't exactly hard to do\SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
The Sage output layout.
 Similar.
\end_layout

\begin_layout Itemize
The Sage error layout.
 Similar.
\end_layout

\begin_layout Itemize
The Sage 
\begin_inset Quotes eld
\end_inset

more input
\begin_inset Quotes erd
\end_inset

 layout.
 I use this when I want 
\begin_inset Quotes eld
\end_inset

Sage input
\begin_inset Quotes erd
\end_inset

 formatting without a Sage prompt first.
\end_layout

\begin_layout Standard
When you use them, it produces something nice, like so:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
R = Polynomial_Ring(QQ, 'x', 5)
\end_layout

\begin_layout SageInput
R.inject_variables()
\end_layout

\begin_layout SageOutput
Defining x0, x1, x2, x3, x4
\end_layout

\begin_layout SageInput
x0 + x5
\end_layout

\begin_layout SageError
NameError: name 'x5' is not defined
\end_layout

\end_deeper
\begin_layout Standard
You might want to try replicating the interaction above immediately below
 this paragraph.
 Notice you don't have to define typeface or color or any of that stuff.
 It takes care of itself automagically.
\end_layout

\begin_layout Standard
The other main thing to keep in mind is that I try to format various 
\begin_inset Quotes eld
\end_inset

privileged text
\begin_inset Quotes erd
\end_inset

 in the narrative in a consistent way.
 I call these 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
Sage words
\end_layout

\end_inset

, 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
Sage constants
\end_layout

\end_inset

, 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Keyboard press
\end_layout

\end_inset

, and 
\begin_inset Flex Boolean Constant
status open

\begin_layout Plain Layout
Boolean Constant
\end_layout

\end_inset

.
 You'll find them in the menu under Insert->Custom Insets->\SpecialChar \ldots{}
.
 Their meanings are roughly:
\end_layout

\begin_layout Itemize
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
Sage words
\end_layout

\end_inset

 are Sage keywords and most things we type in Sage.
\end_layout

\begin_layout Itemize
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
Sage constants
\end_layout

\end_inset

 are things we type in Sage, or that Sage outputs, which have more or less
 a constant meaning in Sage, though they're not always constant since we
 can often redefine them, though we really shouldn't.
 Mostly I'm reserving it for numbers like 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
e
\end_layout

\end_inset

 or 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
I
\end_layout

\end_inset

, prefedined rings like 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
AA
\end_layout

\end_inset

, 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
QQ
\end_layout

\end_inset

, and exceptions like 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RuntimeError
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
I use 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Keyboard press
\end_layout

\end_inset

 to indicate a sequence of characters which is not necessarily a Sage interactio
n, like pressing 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Tab
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
I don't think you'll need 
\begin_inset Flex Boolean Constant
status open

\begin_layout Plain Layout
Boolean constant
\end_layout

\end_inset

 but I use it exclusively for 
\begin_inset Flex Boolean Constant
status open

\begin_layout Plain Layout
True
\end_layout

\end_inset

 or 
\begin_inset Flex Boolean Constant
status open

\begin_layout Plain Layout
False
\end_layout

\end_inset

.
 Hopefully I've capitalized them consistently.
 I think 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

 has a way to ensure they are consistently capitalized, but in any case
 you don't have to worry about it.
\end_layout

\begin_layout Standard
If you can, try to set images at a height of 1.5
\begin_inset space ~
\end_inset

in.
 You'll see this in the Graphics dialogue (Insert->Graphics\SpecialChar \ldots{}
) as 
\begin_inset Quotes eld
\end_inset

Set height.
\begin_inset Quotes erd
\end_inset

 If you feel the height needs to be a little more or a little less, feel
 free to do that, but I've been aiming for consistency.
 I can probably be convinced to go for consistently larger, if you & John
 think that's been a problem, but no one has complained about that.
\end_layout

\begin_layout Standard
Thanks to the custom insets, you shouldn't ever have to worry about changing
 typeface or color unless you want something like
\end_layout

\begin_layout Standard
\align center

\size huge
\color red
PANIC!
\size default
\color inherit

\begin_inset Index idx
status open

\begin_layout Plain Layout
PANIC@
\color red
PANIC
\begin_inset ERT
status open

\begin_layout Plain Layout

"
\end_layout

\end_inset

!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Notice that I add a special index entry for 
\color red
PANIC!
\color inherit
 which in theory should make the index somewhat entertaining.

\emph on
 You can emphasis if you want;
\emph default
 that's 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Ctrl+E
\end_layout

\end_inset

 on a non-Mac computer and 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Cmd+E
\end_layout

\end_inset

 on a Mac.
 (Don't remember what you have.) 
\end_layout

\begin_layout Standard
I think that covers everything.
 Let me know if you have questions.
\end_layout

\begin_layout Chapter*
Repeating yourself inductively
\end_layout

\begin_layout Standard
Another form of repetition is called 
\emph on
recursion
\emph default
.
 The term literally means, 
\begin_inset Quotes eld
\end_inset

running again,
\begin_inset Quotes erd
\end_inset

 because the idea is that an algorithm solves a problem by breaking it into
 simpler cases, invoking itself on those smaller cases, then putting the
 results back together.
 Those smaller cases typically break their cases into even smaller cases.
 This may sound a bit dodgy: What's to stop us from hitting an infinite
 chain?
\end_layout

\begin_layout Standard
When organizing a recursion, we try to set it up in such a way that this
 strategy creates a chain of problems that lead to a smallest possible element.
 If we can relate them to the natural numbers, then even better, the natural
 numbers enjoy a property called the 
\series bold
well-ordering property
\series default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
well-ordering property
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
natural numbers!well-ordering property
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\emph on
Every nonempty subset of 
\begin_inset Formula $\mathbb{N}$
\end_inset

 has a least element.
\end_layout

\begin_layout Section*
Recursion
\end_layout

\begin_layout Subsection*
A classical example
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pascal's triangle|(
\end_layout

\end_inset

A number of problems translate naturally to recursion.
 Another example is Pascal's triangle, which looks like so:
\begin_inset Formula 
\[
\begin{array}{ccccccccccc}
 &  &  &  &  & 1\\
 &  &  &  & 1 &  & 1\\
 &  &  & 1 &  & 2 &  & 1\\
 &  & 1 &  & 3 &  & 3 &  & 1\\
 & 1 &  & 4 &  & 6 &  & 4 &  & 1\\
\iddots &  &  &  &  & \vdots &  &  &  &  & \ddots
\end{array}
\]

\end_inset

The rows of this triangle appear in many places, such as the expansion of
 binomials:
\begin_inset Formula 
\[
\begin{array}{ccccccccccccc}
\left(x+1\right)^{0} & = &  &  &  &  &  & 1\\
\left(x+1\right)^{1} & = &  &  &  &  & 1x & + & 1\\
\left(x+1\right)^{2} & = &  &  &  & 1x^{2} & + & 2x & + & 1\\
\left(x+1\right)^{3} & = &  &  & 1x^{3} & + & 3x^{2} & + & 3x & + & 1\\
\left(x+1\right)^{4} & = &  & 1x^{4} & + & 4x^{3} & + & 6x^{2} & + & 4x & + & 1\\
\vdots &  & \iddots &  &  &  &  &  &  &  &  &  & \ddots
\end{array}
\]

\end_inset

Take a moment to try and deduce the triangle's pattern.
\end_layout

\begin_layout Standard
Do you see it? if not, take another moment to try and work it out.
\end_layout

\begin_layout Standard
Hopefully you saw that each row is defined in the following way.
 Let the top row be row
\begin_inset space ~
\end_inset

1, the next row down row
\begin_inset space ~
\end_inset

2, and so forth.
\end_layout

\begin_layout Itemize
The first and last elements on 
\emph on
each
\emph default
 row are both
\begin_inset space ~
\end_inset

1.
\end_layout

\begin_layout Itemize
The remaining elements satisfy 
\begin_inset Formula $q_{j}=p_{j-1}+p_{j}$
\end_inset

, where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q_{j}$
\end_inset

 is the element in entry 
\begin_inset Formula $j$
\end_inset

 on row 
\begin_inset Formula $i$
\end_inset

, and
\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{j-1}$
\end_inset

 and 
\begin_inset Formula $p_{j}$
\end_inset

 are the elements in entries 
\begin_inset Formula $j-1$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 on row 
\begin_inset Formula $i-1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
To know the entries in row
\begin_inset space ~
\end_inset


\begin_inset Formula $i$
\end_inset

, then, we first need to know the entries on row 
\begin_inset Formula $i-1$
\end_inset

.
 We can loop through those entries to give us the subsequent entries.
 We know how many entries there are in that row --- 
\begin_inset Formula $i-1$
\end_inset

, though we can also inquire from the row itself
\begin_inset Foot
status open

\begin_layout Plain Layout
In the pseudocode, we could have written 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\left|\textit{prev}\right|$
\end_inset


\begin_inset Quotes erd
\end_inset

 to indicate this.
 In the Sage code, we could simply write 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
prev.len()
\end_layout

\end_inset

.
\end_layout

\end_inset

 --- so we can apply a definite loop.
 This gives us the following, recursive pseudocode to compute row 
\begin_inset Formula $i$
\end_inset

:
\end_layout

\begin_layout Pseudocode

\end_layout

\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
pascals_row
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $i\in\mathbb{N}$
\end_inset

, the desired row of Pascal's triangle
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
the sequence of numbers in row 
\begin_inset Formula $i$
\end_inset

 of Pascal's triangle
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $i=1$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
result
\emph default
 = [1]
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else if
\series default
 
\begin_inset Formula $i=2$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
result
\emph default
 = [1,1]
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
prev
\emph default
 = 
\emph on
pascals_row
\emph default
(
\begin_inset Formula $i-1$
\end_inset

)
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
result
\emph default
 = [1]
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
for
\series default
 
\begin_inset Formula $j\in\left(2,3,\ldots,i-1\right)$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

append 
\begin_inset Formula $\textit{prev}_{j-1}+\textit{prev}_{j}$
\end_inset

 to 
\emph on
result
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\emph on
result
\end_layout

\begin_layout Standard
\noindent
This translates to the following Sage code:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
def pascals_row(i):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if i == 1:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = [1]
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

elif i == 2:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = [1, 1]
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

prev = pascals_row(i - 1)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = [1]
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for j in xrange(1, i - 1):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result.append(prev[j-1] + prev[j])
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result.append(1)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return result
\end_layout

\end_deeper
\begin_layout Standard
\noindent
We can verify it on the lines we saw above, and generate more that you can
 verify by hand:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
pascals_row(1)
\end_layout

\begin_layout SageOutput
[1]
\end_layout

\begin_layout SageInput
pascals_row(5)
\end_layout

\begin_layout SageOutput
[1, 4, 6, 4, 1]
\end_layout

\begin_layout SageInput
pascals_row(10)
\end_layout

\begin_layout SageOutput
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pascal's triangle|)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
An example so classical it's medieval
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fibonacci sequence|(
\end_layout

\end_inset

The next example is one of the fundamental problems of mathematics,
\end_layout

\begin_layout Standard
\align center

\emph on
How quickly will a population of bunnies grow?
\end_layout

\begin_layout Standard
\noindent
You think we're joking, but we're not.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "At least one journal"
target "http://www.fq.math.ca"

\end_inset

is dedicated to these bunnies.
\end_layout

\end_inset

 As you might guess, these bunnies are no ordinary bunnies; they obey some
 special laws of reproduction:
\end_layout

\begin_layout Itemize
In the beginning, there was one pair --- but they were immature.
\end_layout

\begin_layout Itemize
Every pair of bunnies takes one season to mature.
\end_layout

\begin_layout Itemize
Once mature, every pair of bunnies produces a new pair of bunnies every
 season.
\end_layout

\begin_layout Itemize
The bunnies are immortal.
 They have no predators, and they obtain their energy from the sun, so they
 never run out of food.
 Amazingly, they never tire of the new children waking them up at night,
 crawling all over them, and generally getting in the way of nobler pursuits,
 such as the contemplation of the form of the ideal bunny.
\begin_inset Foot
status open

\begin_layout Plain Layout
Gratuitous (and irrelevant) reference to Platonic philosophy included at
 no extra charge.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
Come to think of it, it may be a wiser idea to call them flowers than bunnies,
 especially since flowers are so much more awesome than bunnies.
 --- Well, that's not actually true, is it? Bunnies eat flowers, but flowers
 don't eat bunnies.
 Wouldn't it be awesome if they were bunny-eating flowers, though? Well,
 no, not really; they made a movie about that, and those flowers almost
 took over the world.
 Kind of weird to realize that bunnies are more peaceful than flowers, isn't
 it? In any case, the die was cast several centuries back when a more clever
 mathematician than we are proposed the problem using bunnies, so bunnies
 it is.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The formula for the number of bunnies in one season is defined by the number
 in the previous two seasons:
\begin_inset Formula 
\[
b_{n}=b_{n-1}+b_{n-2}.
\]

\end_inset

This is a perfect example of recursion.
 It is natural to try and implement this recursively with a function that
 accepts an integer for the number of seasons that have passed.
 If it is
\begin_inset space ~
\end_inset

1 or
\begin_inset space ~
\end_inset

2, the answer is easy: 1.
 Otherwise, we compute the number of bunnies in the previous two seasons.
\begin_inset CommandInset label
LatexCommand label
name "fibonacci algorithm"

\end_inset


\end_layout

\begin_layout Pseudocode

\end_layout

\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
funny_bunnies
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, the number of seasons
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
the number of bunnies after 
\begin_inset Formula $n$
\end_inset

 seasons
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $n=1$
\end_inset

 
\series bold
or
\series default
 
\begin_inset Formula $n=2$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 1
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 
\emph on
funny_bunnies
\emph default
(
\begin_inset Formula $n-1$
\end_inset

) + 
\emph on
funny_bunnies
\emph default
(
\begin_inset Formula $n-2$
\end_inset

)
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\emph on
result
\end_layout

\begin_layout Standard
\noindent
To translate this to Sage code, keep in mind that 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
xrange()
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 iterate on the last value, so we need its limit to be 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
n-1
\end_layout

\end_inset

:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
def funny_bunnies(n):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if n == 1 or n == 2:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = 1
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = funny_bunnies(n-1) + funny_bunnies(n-2)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return result
\end_layout

\begin_layout SageInput
[funny_bunnies(i) for i in xrange(2,10)]
\end_layout

\begin_layout SageOutput
[2, 3, 5, 8, 13, 21, 34]
\end_layout

\end_deeper
\begin_layout Standard
\noindent
That's a very interesting list of numbers.
 It is so interesting that it's named after a mathematician who described
 it during the Middle Ages, Leonardo da Pisa, better known as Fibonacci,
\begin_inset Foot
status open

\begin_layout Plain Layout
Fibonacci lived in a period known as the High Middle Ages, and didn't care
 about bunnies so much as the fact that people were still using I, V, X,
 L, C, D, and M to write numbers and do arithmetic --- Roman numerals, that
 is.
 He realized this was very inefficient, and it would be better to use the
 Hindu-Arabic way of writing numbers: 0, 1, 2, \SpecialChar \ldots{}
, 9 and all that.
 Trouble was, most people were accustomed to working with a old-timey calculator
 called an 
\emph on
abacus
\emph default
, and had been trained how to use an abacus with Roman numerals.
 Then as now, people were reluctant to give up a computational crutch.
\end_layout

\begin_layout Plain Layout
To get around this, he wrote a book called 
\emph on
Liber Abaci
\emph default
 (
\begin_inset Quotes eld
\end_inset

Book of the Abacus
\begin_inset Quotes erd
\end_inset

).
 The book's main point was to show how you could solve all the same problems
 with Hindu-Arabic numbers 
\emph on
without
\emph default
 using an abacus, and work far more efficiently, to boot.
 Getting work done faster allowed one to do more business.
 The Platonic bunnies were one of the examples he used in the book.
 It was quite possibly the first time someone used a funny bunny to make
 money.
\end_layout

\begin_layout Plain Layout
Oh, we're not done making you groan yet, not by a long shot.
 You may think 
\emph on
Liber Abaci
\emph default
 kind of a dull title --- certainly not as catchy as the slogan, 
\begin_inset Quotes eld
\end_inset

Think Different,
\begin_inset Quotes erd
\end_inset

 though Fibonacci would have had stronger grounds to use that slogan than
 anyone who popularized it today --- but people back then were interested
 more in substance than in style, so Fibonacci succeeded both in weaning
 people off Roman numerals and in getting his name attached to a sequence
 of numbers that, ironically, had been studied by Indian (Hindu) mathematicians
 long before Leo was himself a Fibonacci number.
\end_layout

\begin_layout Plain Layout
All this goes to show that the High Middle Ages suffered a critical shortage
 of 21st century 
\begin_inset Quotes eld
\end_inset

brights
\begin_inset Quotes erd
\end_inset

 who could inform them that they were, in fact, supposed to be ignorant
 poo-flingers disinterested in science and mathematics.
\end_layout

\begin_layout Plain Layout
(And, yes, we do recognize the irony in referring to an abacus as a 
\begin_inset Quotes eld
\end_inset

computational crutch
\begin_inset Quotes erd
\end_inset

 in a text dedicated to doing math problems with the Sage computer algebra
 system, but this footnote is designed to be rich in irony.)
\end_layout

\end_inset

 so people call it the 
\series bold
Fibonacci sequence
\series default
.
 We can describe it as follows:
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Formula $F$
\end_inset

 stands for 
\begin_inset Quotes eld
\end_inset

funny,
\begin_inset Quotes erd
\end_inset

 not 
\begin_inset Quotes eld
\end_inset

Fibonacci.
\begin_inset Quotes erd
\end_inset

 Why do you ask?
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "pg: Fibaonacci definition"

\end_inset


\begin_inset Formula 
\[
F_{\textrm{next}}=F_{\textrm{total}}+F_{\textrm{mature}}.
\]

\end_inset

That means, 
\begin_inset Quotes eld
\end_inset

the number of bunnies next season is the sum of the total number of bunnies
 and the number of mature bunnies.
\begin_inset Quotes erd
\end_inset

 We could also say that the number of total bunnies is the 
\begin_inset Quotes eld
\end_inset

current
\begin_inset Quotes erd
\end_inset

 number of bunnies, while the number of mature bunnies is the number of
 bunnies we had last season.
 That means 
\begin_inset Quotes eld
\end_inset

the number of bunnies next season is the sum of the number of bunnies this
 season and the number of bunnies last season.
\begin_inset Quotes erd
\end_inset

 So we could write:
\begin_inset Formula 
\[
F_{\textrm{next}}=F_{\textrm{curr}}+F_{\textrm{prev}}.
\]

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Fibonacci sequence|)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
An example you can't actually program
\end_layout

\begin_layout Standard
Another example is the proof technique called 
\emph on
induction.

\emph default
 The principle of induction is that:
\end_layout

\begin_layout Itemize
if you can prove:
\end_layout

\begin_deeper
\begin_layout Itemize
a property applies to
\begin_inset space ~
\end_inset

1, and
\end_layout

\begin_layout Itemize
whenever it applies to 
\begin_inset Formula $n$
\end_inset

, it also applies to 
\begin_inset Formula $n+1$
\end_inset

,
\end_layout

\end_deeper
\begin_layout Itemize
then the property applies to all the positive integers.
\end_layout

\begin_layout Standard
The idea is that if we can show the first bullet is true, then the second
 bullet is true for any positive integer 
\begin_inset Formula $m$
\end_inset

 because
\end_layout

\begin_layout Itemize
if it's true for 
\begin_inset Formula $m-1$
\end_inset

, then it's true for 
\begin_inset Formula $m$
\end_inset

; and
\end_layout

\begin_layout Itemize
if it's true for 
\begin_inset Formula $m-2$
\end_inset

, then it's true for 
\begin_inset Formula $m-1$
\end_inset

, and
\begin_inset Newline newline
\end_inset

\SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
if it's true for
\begin_inset space ~
\end_inset

1, then it's true for 2.
\end_layout

\begin_layout Standard
We know it's true for
\begin_inset space ~
\end_inset

1 (that's in the first bullet), so the chain of implications tells us it's
 true for 
\begin_inset Formula $m$
\end_inset

, which was an arbitrary positive integer.
\end_layout

\begin_layout Section*
Alternatives to recursion
\end_layout

\begin_layout Standard
Recursion is fairly common, and reasonably easy to implement, but it may
 not always the best approach.
 It's not hard at all to compute Pascal's triangle even to the 900th row,
 and you might be able to take it further if Sage did not place a limit
 on the number of times you can apply recursion:
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RuntimeError
\end_layout

\end_inset

!
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
maximum recursion depth exceeded while calling a Python object
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
P = pascals_row(900)
\end_layout

\begin_layout SageInput
len(P)
\end_layout

\begin_layout SageOutput
900
\end_layout

\begin_layout SageInput
P[-3]
\end_layout

\begin_layout SageOutput
403651
\end_layout

\begin_layout SageInput
P = pascals_row(1000)
\end_layout

\begin_layout SageError
RuntimeError: maximum recursion depth exceeded while calling a Python object
\end_layout

\end_deeper
\begin_layout Standard
\noindent
This limit is there for good reason, by the way; recursion can use up quite
 a bit of a special sort of memory,
\begin_inset Foot
status open

\begin_layout Plain Layout
For those who know some computer science, we're talking about the stack.
\end_layout

\end_inset

 and too deep a recursion can also indicate an infinite loop, or at least
 that something has gone terribly awry.
\end_layout

\begin_layout Standard
With the Fibonacci sequence, things go awry rather quickly, but in a different
 way.
 Try computing the 
\begin_inset Formula $n$
\end_inset

th Fibonacci number for really-not-very-large-at-all values of 
\begin_inset Formula $n$
\end_inset

, and you'll see the length the problems take a sharp turn upwards quickly.
 On the authors' machines, for instance, there is already a noticeable lag
 at 
\begin_inset Formula $n=30$
\end_inset

; 
\begin_inset Formula $n=35$
\end_inset

 takes several seconds; and for 
\begin_inset Formula $n=40$
\end_inset

 you might just be able to make yourself a cup of coffee
\begin_inset Foot
status open

\begin_layout Plain Layout
Whether you'd want to drink it is another story, but before the authors
 get into another argument on caffeinated drinks, we'll stop there.
\end_layout

\end_inset

 before it finished.
 You might think you could get around this delay with a faster computer,
 and you'd be wrong, very wrong.
 The problem is that there are too many branches at each step.
 To see this clearly, let's expand a computation of the 7th Fibonacci number
 down to one of the two base cases:
\begin_inset Formula 
\begin{align*}
F_{7} & =F_{6}+F_{5}\\
 & =\left(F_{5}+F_{4}\right)+\left(F_{4}+F_{3}\right)\\
 & =\left[\left(F_{4}+F_{3}\right)+\left(F_{3}+F_{2}\right)\right]+\left[\left(F_{3}+F_{2}\right)+\left(F_{2}+F_{1}\right)\right]\\
 & =\left[\left[\left(F_{3}+F_{2}\right)+\left(F_{2}+F_{1}\right)\right]+\left(F_{2}+F_{1}\right)+F_{2}\right]+\left[\left[\left(F_{2}+F_{1}\right)+F_{2}\right]+\left(F_{2}+F_{1}\right)\right]\\
 & =\left[\left[\left[\left(F_{2}+F_{1}\right)+F_{2}\right]+\left(F_{2}+F_{1}\right)\right]+\left(F_{2}+F_{1}\right)+F_{2}\right]\\
 & \qquad+\left[\left[\left(F_{2}+F_{1}\right)+F_{2}\right]+\left(F_{2}+F_{1}\right)\right]
\end{align*}

\end_inset

Twelve 
\begin_inset Formula $F$
\end_inset

's are 
\emph on
not
\emph default
 the base cases 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

; each of those requires a recursion.
 That's an awful lot, but it doesn't sound that bad.
 On the other hand, consider the next number,
\begin_inset Formula 
\[
F_{8}=F_{7}+F_{6}.
\]

\end_inset

We've already counted 12 recursions for 
\begin_inset Formula $F_{7}$
\end_inset

, and you can look up to see that 
\begin_inset Formula $F_{6}$
\end_inset

 requires
\begin_inset space ~
\end_inset

7.
 So 
\begin_inset Formula $F_{8}$
\end_inset

 will want
\begin_inset space ~
\end_inset


\begin_inset Formula $12+7+1=20$
\end_inset

 recursions.
 (We need
\begin_inset space ~
\end_inset

1 extra for the expansion of 
\begin_inset Formula $F_{7}$
\end_inset

 itself.) You can see immediately that the number of recursions of the Fibonacci
 sequence grows in a Fibonacci-like fashion:
\begin_inset Formula 
\[
0,0,1,2,4,7,12,20,33,54,\ldots
\]

\end_inset

Already 
\begin_inset Formula $F_{10}$
\end_inset

 requires 
\begin_inset Formula $54\approx5\times10$
\end_inset

 recursions; notice the jump in size from 
\begin_inset Formula $F_{7}$
\end_inset

, which required 
\begin_inset Quotes eld
\end_inset

only
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $12\approx2\times7$
\end_inset

.
 With the Fibonacci sequence, the number of recursions is growing too fast!
\end_layout

\begin_layout Standard
Computing the 100th Fibonacci number might, therefore, seem out of reach,
 but there are several ways around this conundrum.
 The first two approaches to solving this problem rely on the fact that
 when computing 
\begin_inset Formula $F_{7}$
\end_inset

, we computed 
\begin_inset Formula $F_{5}$
\end_inset

 twice:
\begin_inset Formula 
\[
F_{7}=F_{6}+F_{5}=\left(\mathbf{F_{5}}+F_{4}\right)+\mathbf{F_{5}}.
\]

\end_inset

We then computed 
\begin_inset Formula $F_{4}$
\end_inset

 three times:
\begin_inset Formula 
\[
F_{7}=\left[\left(\mathbf{F_{4}}+F_{3}\right)+\mathbf{F_{4}}\right]+\left(\mathbf{F_{4}}+F_{3}\right).
\]

\end_inset

\SpecialChar \ldots{}
and so forth.
 So the problem isn't that the Fibonacci 
\emph on
inherently
\emph default
 requires an unreasonable amount of recursion; it's that we're wasting a
 lot of computations that we could reuse.
\end_layout

\begin_layout Subsection*
Caching
\end_layout

\begin_layout Standard
One way to avoid wasting computations is to 
\begin_inset Quotes eld
\end_inset

remember
\begin_inset Quotes erd
\end_inset

 them what's called a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
caching
\end_layout

\end_inset

cache
\series default
.
 You can think of it this way
\begin_inset Index idx
status open

\begin_layout Plain Layout
bad jokes
\end_layout

\end_inset

: we 
\emph on
stash
\emph default
 previous results in the 
\emph on
cache
\emph default
.
 To implement the cache, we use a 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
global variable
\end_layout

\end_inset

global
\series default
 variable; that is, a variable that exists outside a function, which we
 can access from inside it.
 The reason for this is that if the cache were merely local to the function,
 then the same values wouldn't be available when we tackle the subproblem.
\end_layout

\begin_layout Standard
We describe two ways to cache results.
 One of them is to do so explicitly, with a list whose 
\begin_inset Formula $i$
\end_inset

th value is the 
\begin_inset Formula $i$
\end_inset

th Fibonacci number.
 We initialize the list as 
\begin_inset Formula $F=\left[1,1\right]$
\end_inset

.
 Whenever we compute a Fibonacci number, we first check whether 
\begin_inset Formula $F$
\end_inset

 already has the value.
 If it does, we return that value rather than recurse.
 If it does not, we compute it, then add it to 
\begin_inset Formula $F$
\end_inset

 at the end.
 For instance, when computing 
\begin_inset Formula $F_{5}$
\end_inset

:
\end_layout

\begin_layout Itemize
We need to compute 
\begin_inset Formula $F_{4}$
\end_inset

 and 
\begin_inset Formula $F_{3}$
\end_inset

.
 We have neither, so we recurse.
\end_layout

\begin_deeper
\begin_layout Itemize
For 
\begin_inset Formula $F_{4}$
\end_inset

, we need to compute 
\begin_inset Formula $F_{3}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

.
 We don't have 
\begin_inset Formula $F_{3}$
\end_inset

, so we recurse.
\end_layout

\begin_deeper
\begin_layout Itemize
For 
\begin_inset Formula $F_{3}$
\end_inset

, we need to compute 
\begin_inset Formula $F_{2}$
\end_inset

 and 
\begin_inset Formula $F_{1}$
\end_inset

.
 We have both, so we compute 
\begin_inset Formula $F_{3}=F_{2}+F_{1}=1+1=2$
\end_inset

 and store that at the end of the list 
\begin_inset Formula $F$
\end_inset

, which is now 
\begin_inset Formula $[1,1,2]$
\end_inset

.
 We then return it
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $F_{2}$
\end_inset

, we already have it, so we return 
\begin_inset Formula $F_{2}=1$
\end_inset

.
\end_layout

\begin_layout Itemize
We now have 
\begin_inset Formula $F_{3}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

 , so we compute 
\begin_inset Formula $F_{4}=F_{3}+F_{2}=2+1=3$
\end_inset

, store that value at the end of the list, and return it.
\end_layout

\end_deeper
\begin_layout Itemize
For 
\begin_inset Formula $F_{3}$
\end_inset

, we 
\emph on
now
\emph default
 have it in the list (it was computed above) so we simply return it.
\end_layout

\end_deeper
\begin_layout Itemize
We now have 
\begin_inset Formula $F_{4}$
\end_inset

 and 
\begin_inset Formula $F_{3}$
\end_inset

, so we compute 
\begin_inset Formula $F_{5}=F_{4}+F_{3}=3+2=5$
\end_inset

, store that value at the end of the list, and return it.
\end_layout

\begin_layout Standard
This saved us the trouble of computing 
\begin_inset Formula $F_{4}$
\end_inset

 more than once, and of computing 
\begin_inset Formula $F_{3}$
\end_inset

 more than once.
 What's more, the definition of the Fibonacci numbers is convenient to this
 method: when it comes time to store 
\begin_inset Formula $F_{n}$
\end_inset

, we already have 
\begin_inset Formula $F_{1}$
\end_inset

, 
\begin_inset Formula $F_{2}$
\end_inset

, \SpecialChar \ldots{}
, 
\begin_inset Formula $F_{n-1}$
\end_inset

 in the list, so we can store it in the right place.
\begin_inset Foot
status open

\begin_layout Plain Layout
Not all recursive sequences are this lucky.
 If the sequence were defined by 
\begin_inset Formula $S_{n}=S_{n-2}+S_{n-3}$
\end_inset

, for instance, you'd have to make sure the cache had the right length before
 storing it.
 So we're a little lucky with the Fibonacci sequence.
\end_layout

\end_inset

 To write pseudocode for this, we introduce a new 
\begin_inset Quotes eld
\end_inset

bold word
\begin_inset Quotes erd
\end_inset

 for our pseudocode: 
\series bold
global
\series default
.
 This heads a list of global variables used by the algorithm; for clarity,
 we list it after 
\series bold
inputs
\series default
 and 
\series bold
outputs
\series default
.
\end_layout

\begin_layout Pseudocode

\end_layout

\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
cached_fibonacci
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 with 
\begin_inset Formula $n\geq1$
\end_inset


\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F_{n}$
\end_inset

, the 
\begin_inset Formula $n$
\end_inset

th Fibonacci number
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
globals
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F$
\end_inset

, a list of Fibonacci numbers (in order)
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $n\leq$
\end_inset

 
\begin_inset Formula $\left|F\right|$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 
\begin_inset Formula $F_{n}$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 
\emph on
cached_fibonacci
\emph default
(
\begin_inset Formula $n-1$
\end_inset

) + 
\emph on
cached_fibonacci
\emph default
(
\begin_inset Formula $n-2$
\end_inset

)
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

append 
\emph on
result
\emph default
 to 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\emph on
result
\end_layout

\begin_layout Standard
\noindent
To turn this into pseudocode, we use the Sage keyword 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
global
\end_layout

\end_inset

,
\begin_inset Index idx
status open

\begin_layout Plain Layout
keyword!
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
global
\end_layout

\end_inset


\end_layout

\end_inset

 which indicates that 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F
\end_layout

\end_inset

 is a variable that lives outside the function.
 This isn't strictly necessary for Sage, but it helps alert readers that
 a global variable is expected.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
F = [1,1]
\end_layout

\begin_layout SageInput
def cached_fibonacci(n):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

global F
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if n <= len(F):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = F[n-1]
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = cached_fibonacci(n-1) 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

+ cached_fibonacci(n-2)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

F.append(result)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return result
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Notice that we had to adjust one item from the pseudocode: instead of returning
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F[n]
\end_layout

\end_inset

, we returned 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F[n-1]
\end_layout

\end_inset

.
 We did this because the pseudocode assumes that lists start with index
\begin_inset space ~
\end_inset

1, but Sage starts its indices at index
\begin_inset space ~
\end_inset

0.
\end_layout

\begin_layout Standard
You can test and compare the results between the two.
 It will become evidence very quickly that 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
cached_fibonacci()
\end_layout

\end_inset

 is much, 
\emph on
much
\emph default
 faster than 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
funny_bunnies()
\end_layout

\end_inset

 once 
\begin_inset Formula $n$
\end_inset

 grows to anything larger than the dinkiest of numbers:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
cached_fibonacci(10)
\end_layout

\begin_layout SageOutput
55
\end_layout

\begin_layout SageInput
cached_fibonacci(25)
\end_layout

\begin_layout SageOutput
75025
\end_layout

\begin_layout SageInput
cached_fibonacci(35)
\end_layout

\begin_layout SageOutput
9227465
\end_layout

\end_deeper
\begin_layout Standard
\noindent
To 
\emph on
really
\emph default
 drive the point home, we'll compute one that would take far too long with
 the recursive implementation:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
cached_fibonacci(100)
\end_layout

\begin_layout SageOutput
354224848179261915075
\end_layout

\end_deeper
\begin_layout Standard

\series bold
\emph on
Don't
\series default
\emph default
 overlook the first line of the code above, where we set 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F = [1,1]
\end_layout

\end_inset

.
 If you forget that, you'll encounter an error.
 If you were a 
\emph on
good
\emph default
 reader and did not make that mistake, we will simulate the error by resetting
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F
\end_layout

\end_inset

, then running 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
cached_fibonacci
\end_layout

\end_inset

:
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
NameError
\end_layout

\end_inset

!
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
global name \SpecialChar \ldots{}
 is not defined
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
reset('F')
\end_layout

\begin_layout SageInput
cached_fibonacci(10)
\end_layout

\begin_layout SageError
NameError: global name 'F' is not defined
\end_layout

\end_deeper
\begin_layout Standard
\noindent
If you were still a good reader and reset 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
F
\end_layout

\end_inset

 to see what would happen, and now you want to run it again, just assign
 it anew:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
F = [1,1]
\end_layout

\begin_layout SageInput
cached_fibonacci(10)
\end_layout

\begin_layout SageOutput
55
\end_layout

\end_deeper
\begin_layout Standard
Two last words to the wise.
 While this algorithm is cached, it is 
\emph on
still recursive;
\emph default
 we haven't changed the fact that, when we encounter a 
\begin_inset Quotes eld
\end_inset

cache miss
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Formula $n$
\end_inset

 is larger than the size of 
\begin_inset Formula $F$
\end_inset

), the algorithm has to call itself.
 Since Sage has a built-in limit for recursion, we still encounter the same
 problem as we did with 
\emph on
pascals_row
\emph default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RuntimeError
\end_layout

\end_inset

!
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
maximum recursion depth exceeded while calling a Python object
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
cached_fibonacci(1000)
\end_layout

\begin_layout SageError
RuntimeError: maximum recursion depth exceeded while calling a Python object
\end_layout

\end_deeper
\begin_layout Standard
\noindent
You can actually change this, but it's dangerous, so we won't tell you how.
 There are usually better options, anyway --- to find one, see the next
 section.
\end_layout

\begin_layout Standard
Finally, you don't usually have to implement caching on your own.
 In the cloud, Sage will give you a cache for free; just type the 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
@cached_function
\end_layout

\end_inset

 and then start the function definition on the line below.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
@cached_function
\end_layout

\begin_layout SageMoreInput
def decorated_fibonacci(n):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if n == 1 or n == 2:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = 1
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = decorated_fibonacci(n-1) 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

+ decorated_fibonacci(n-2)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return result
\end_layout

\begin_layout SageInput
cached_fibonacci(100)
\end_layout

\begin_layout SageOutput
354224848179261915075
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Notice that we obtained the same result as with our home-grown cache.
\end_layout

\begin_layout Subsection*
Turning recursion into a loop
\end_layout

\begin_layout Standard
Another way to avoid wasting computations is to reformulate the recursion
 as a loop.
 Let 
\begin_inset Formula $b_{\textrm{mat}}$
\end_inset

 count the pairs of mature bunnies, let 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 count the total pairs of bunnies, and let 
\begin_inset Formula $b_{\textrm{next}}$
\end_inset

 count the pairs of bunnies we can expect next season.
 Since the bunnies are immortal, 
\begin_inset Formula $b_{\textrm{next}}$
\end_inset

 will count all 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 of the bunnies we have now, but since each mature pair produces a new pair,
 
\begin_inset Formula $b_{\textrm{next}}$
\end_inset

 must also count all 
\begin_inset Formula $b_{\textrm{mat}}$
\end_inset

 mature pairs twice to account for next season's new pairs.
 So
\begin_inset Formula 
\[
b_{\textrm{next}}=b_{\textrm{tot}}+b_{\textrm{mat}}.
\]

\end_inset

Once the next season comes, 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 will be the number of mature bunnies that are now producing pairs, while
 
\begin_inset Formula $b_{\textrm{next}}$
\end_inset

 will be the new bunny total, so we could replace 
\begin_inset Formula $b_{\textrm{mat}}$
\end_inset

 by 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 and 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 by 
\begin_inset Formula $f_{\textrm{next}}$
\end_inset

 to compute the following season's total.
 And so forth.
 Since we know the first two season's values already, we never need to count
 those.
 Keeping in mind that 
\begin_inset Formula $n=1$
\end_inset

 is the first season and 
\begin_inset Formula $n=2$
\end_inset

 the second, we need the loop to calculate 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset

 for 
\begin_inset Formula $n=3$
\end_inset

, 
\begin_inset Formula $n=4$
\end_inset

, \SpecialChar \ldots{}
 That suggests the following pseudocode.
\end_layout

\begin_layout Pseudocode

\end_layout

\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
immortal_bunnies
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, the number of seasons
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
the number of 
\begin_inset Quotes eld
\end_inset

immortal
\begin_inset Quotes erd
\end_inset

 bunnies after 
\begin_inset Formula $n$
\end_inset

 seasons
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\begin_inset Formula $b_{\textrm{mat}}=b_{\textrm{tot}}=1$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
repeat
\series default
 
\begin_inset Formula $n-2$
\end_inset

 times
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\begin_inset Formula $b_{\textrm{next}}=b_{\textrm{tot}}+b_{\textrm{mat}}$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\begin_inset Formula $b_{\textrm{mat}}=b_{\textrm{tot}}$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\begin_inset Formula $b_{\textrm{tot}}=b_{\textrm{next}}$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\begin_inset Formula $b_{\textrm{tot}}$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To translate this to Sage code, keep in mind that 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
xrange()
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 iterate on the last value, so we need its limit to be 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
n-1
\end_layout

\end_inset

.
 It is also more 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

 in Sage to start counting at 
\begin_inset Formula $n=0$
\end_inset

, so the loop will differ slightly form the pseudocode:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
def immortal_bunnies(n):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b_mat = b_tot = 1
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for each in xrange(n-1):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b_next = b_tot + b_mat
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b_mat, b_tot = b_tot, b_next
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return b_tot
\end_layout

\begin_layout SageInput
[immortal_bunnies(i) for i in xrange(2,10)]
\end_layout

\begin_layout SageOutput
[2, 3, 5, 8, 13, 21, 34, 55]
\end_layout

\end_deeper
\begin_layout Standard
Unlike caching, Sage does not provide an automatic method that turns a recursive
 function into a looped function.
 Doing this is something we have to work out on our own, reasoning from
 the logic of the problem.
 As is considered an advanced topic in computer science, we do not dwell
 on it further.
 The interested reader can find further information in computer science
 texts that discuss 
\begin_inset Quotes eld
\end_inset

dynamic programming.
\begin_inset Quotes erd
\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout

\size small
The inventor of dynamic programming once said that he invented the term
 because his supervisor harbored 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "a pathological fear and hatred of the word research. ...You can imagine how he felt, then, about the term mathematical."
target "https://en.wikipedia.org/wiki/Dynamic_programming#History"

\end_inset


\begin_inset Quotes erd
\end_inset

 Using a term like 
\begin_inset Quotes eld
\end_inset

dynamic programming
\begin_inset Quotes erd
\end_inset

 helped him steer clear of his supervisor's wrath.
 He added, 
\begin_inset Quotes eld
\end_inset

I thought dynamic programming was a good name\SpecialChar \ldots{}
 not even a Congressman could
 object to.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Eigenvalues and eigenvectors resolve a bunny dilemma
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset label
LatexCommand label
name "sub: eigenvalues and eigenvectors resolve a bunny dilemma"

\end_inset

You may not be familiar with eigenvalues and eigenvectors, even if you've
 seen them in a class.
 We conclude this chapter with an illustration of how immensely useful they
 can be.
\end_layout

\begin_layout Standard
As you have probably noticed, even the non-recursive implementations of
 the Fibonacci sequence rely on its recursive description, whose recursive
 nature requires us to know some previous values.
 It would be nice to have a formula that didn't depend on previous values,
 at least not explicitly.
 Such a formula is called a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
sequence!closed form
\end_layout

\end_inset

closed form of a sequence.
\end_layout

\begin_layout Standard
Another way to describe this is as a matrix equation.
 The matrices
\begin_inset Formula 
\[
\left(\begin{array}{c}
F_{\textrm{curr}}\\
F_{\textrm{prev}}
\end{array}\right)\quad\textrm{and}\quad\left(\begin{array}{c}
F_{\textrm{next}}\\
F_{\textrm{curr}}
\end{array}\right)
\]

\end_inset

represent the information we need both this season and next season to compute
 the following season's bunnies.
 Now, the sum of the numbers in the first matrix gives us the top element
 of the second matrix, while the top number of the first matrix gives us
 the bottom number of the second.
 We can describe this relationship using a matrix equation:
\begin_inset Formula 
\[
\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)\left(\begin{array}{c}
F_{\textrm{curr}}\\
F_{\textrm{prev}}
\end{array}\right)=\left(\begin{array}{c}
F_{\textrm{next}}\\
F_{\textrm{curr}}
\end{array}\right).
\]

\end_inset

What's more, multiplying by powers of the matrix
\begin_inset Formula 
\[
M=\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)
\]

\end_inset

ratchets the numbers higher up the list.
 To wit,
\begin_inset Formula 
\[
\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)^{5}\left(\begin{array}{c}
1\\
1
\end{array}\right)=\left(\begin{array}{c}
13\\
8
\end{array}\right),
\]

\end_inset

which you will recognize as the 4th and 5th numbers in the list our program
 produced, which are 
\begin_inset Formula $F_{6}$
\end_inset

 and 
\begin_inset Formula $F_{7}$
\end_inset

, by which we mean the number of bunnies in the 6th and 7th seasons.
 In general,
\begin_inset Formula 
\[
\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)^{n-2}\left(\begin{array}{c}
1\\
1
\end{array}\right)=\left(\begin{array}{c}
F_{n}\\
F_{n-1}
\end{array}\right),
\]

\end_inset

since after all
\begin_inset Formula 
\[
\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)^{1}\left(\begin{array}{c}
1\\
1
\end{array}\right)=\left(\begin{array}{c}
2\\
1
\end{array}\right),\quad\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)^{2}\left(\begin{array}{c}
1\\
1
\end{array}\right)=\left(\begin{array}{cc}
1 & 1\\
1 & 0
\end{array}\right)^{1}\left(\begin{array}{c}
2\\
1
\end{array}\right)=\left(\begin{array}{c}
3\\
2
\end{array}\right),
\]

\end_inset

and so forth.
\end_layout

\begin_layout Standard
If we can find a simple formula for powers of the matrix, we should be able
 to use it to find our desired closed form.
 As it happens, a very convenient result from linear algebra comes in handy
 here.
 An 
\series bold
eigenvector
\begin_inset Index idx
status open

\begin_layout Plain Layout
vector!eigenvector
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
eigenvector
\end_layout

\end_inset


\series default
 
\begin_inset Formula $\mathbf{e}$
\end_inset

 of a matrix 
\begin_inset Formula $M$
\end_inset

 over a ring 
\begin_inset Formula $R$
\end_inset

 is a vector related to an eigenvalue 
\begin_inset Formula $\lambda\in R$
\end_inset

 such that
\begin_inset Formula 
\[
M\mathbf{e}=\lambda\mathbf{e};
\]

\end_inset

that is, 
\begin_inset Formula $M$
\end_inset

 changes the 
\begin_inset Quotes eld
\end_inset

length
\begin_inset Quotes erd
\end_inset

 of the vector.
 Eigenvectors and their eigenvalues have a number of uses, one of which
 now comes to our aid.
\end_layout

\begin_layout Named Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Eigendecomposition Theorem.
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
theorems!Eigendecomposition Theorem
\end_layout

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be an 
\begin_inset Formula $n\times n$
\end_inset

 matrix with linearly independent eigenvectors 
\begin_inset Formula $\mathbf{e}_{1}$
\end_inset

, \SpecialChar \ldots{}
, 
\begin_inset Formula $\mathbf{e}_{n}$
\end_inset

 and corresponding eigenvalues 
\begin_inset Formula $\lambda_{1}$
\end_inset

, \SpecialChar \ldots{}
, 
\begin_inset Formula $\lambda_{n}$
\end_inset

.
 We can rewrite 
\begin_inset Formula $M$
\end_inset

 as 
\begin_inset Formula $Q\Lambda Q^{-1}$
\end_inset

 where
\begin_inset Formula 
\[
Q=\left(\mathbf{e}_{1}|\mathbf{e}_{2}|\cdots|\mathbf{e}_{n}\right)\quad\textrm{and}\quad\Lambda=\left(\begin{array}{cccc}
\lambda_{1}\\
 & \lambda_{2}\\
 &  & \ddots\\
 &  &  & \lambda_{n}
\end{array}\right).
\]

\end_inset

(The notation for 
\begin_inset Formula $Q$
\end_inset

 means that the 
\begin_inset Formula $i$
\end_inset

th column of 
\begin_inset Formula $Q$
\end_inset

 is the 
\begin_inset Formula $i$
\end_inset

th eigenvector of 
\begin_inset Formula $M$
\end_inset

.)
\end_layout

\begin_layout Standard
It's easy to verify this in Sage for 
\begin_inset Formula $M$
\end_inset

.
 Let's compute the eigenvectors first.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
evecs = M.eigenvectors_right()
\end_layout

\begin_layout SageInput
evecs
\end_layout

\begin_layout SageOutput
[(-0.618033988749895?, [(1, -1.618033988749895?)], 1),
\end_layout

\begin_layout SageOutput
\begin_inset space ~
\end_inset

(1.618033988749895?, [(1, 0.618033988749895?)], 1)]
\end_layout

\end_deeper
\begin_layout Standard
\noindent
What does all this mean? If you study the help text\SpecialChar \ldots{}

\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
M.eigenvectors_right?
\end_layout

\end_deeper
\begin_layout Standard
\noindent
\SpecialChar \ldots{}
you will see that the list holds one tuple per eigenvector, and the tuple
 itself contains the eigenvalue, the eigenvector, and the eigenvector's
 multiplicity.
\end_layout

\begin_layout Standard
For our purposes, the eigenvalues and eigenvectors suffice.
 It is relatively easy to extract them, but
\end_layout

\begin_layout Itemize
we want exact values, not approximate ones, and
\end_layout

\begin_layout Itemize
what do those question marks mean, anyway?
\end_layout

\begin_layout Standard
It may surprise you to learn that the question marks do 
\emph on
not
\emph default
 indicate uncertainty.
 They indicate that the numbers lie in a special field called the field
 of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
algebraic numbers|seealso
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
AA
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

algebraic numbers.
 Sage denotes this field with the symbol 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
AA
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
AA
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
a, b = evecs[0][0], evecs[1][0]
\end_layout

\begin_layout SageInput
type(a)
\end_layout

\begin_layout SageOutput
<class 'sage.rings.qqbar.AlgebraicNumber'>
\end_layout

\end_deeper
\begin_layout Standard
\noindent
The algebraic numbers are the smallest field containing all the roots of
 polynomials with integer coefficients, so we can always find a 
\begin_inset Quotes eld
\end_inset

nice-looking
\begin_inset Quotes erd
\end_inset

 polynomial that has them as a root.
 In addition, can often rewrite them as an expression in radicals.
 The following messages to algebraic numbers perform these tasks:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="25col%">
<column alignment="left" valignment="top" width="50col%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
a
\emph default

\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.minpoly()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns the polynomial of smallest degree that has 
\emph on
a
\emph default
 as a root
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
a
\emph default

\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.radical_expression()
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
returns a radical expression equivalent to 
\emph on
a
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
You can find many more messages in the usual manner, by typing the name
 of a variable whose value is an algebraic number, following it with a period,
 then pressing the 
\begin_inset Flex Keyboard Press
status open

\begin_layout Plain Layout
Tab
\end_layout

\end_inset

 key.
\end_layout

\begin_layout Standard
For now, let's try these on our present eigenvector.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
a.minpoly()
\end_layout

\begin_layout SageOutput
x^2 - x - 1
\end_layout

\begin_layout SageInput
a.radical_expression()
\end_layout

\begin_layout SageOutput
-1/2*sqrt(5) + 1/2
\end_layout

\begin_layout SageInput
b.minpoly()
\end_layout

\begin_layout SageOutput
x^2 - x - 1
\end_layout

\begin_layout SageInput
b.radical_expression()
\end_layout

\begin_layout SageOutput
1/2*sqrt(5) + 1/2
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Both numbers have the same minimal polynomial,
\begin_inset Foot
status open

\begin_layout Plain Layout
This makes sense if you have studied this.
 If you haven't, watch for a linear algebra class coming soon to a semester
 near you!
\end_layout

\end_inset

 but their radical expressions are different.
 They aren't 
\emph on
that
\emph default
 different, though; we'll call them
\begin_inset Foot
status open

\begin_layout Plain Layout
Some trivia.
 Since 
\begin_inset Formula $\varphi$
\end_inset

 is a root of 
\begin_inset Formula $x^{2}-x-1$
\end_inset

, we know that 
\begin_inset Formula $\varphi^{2}-\varphi-1=0$
\end_inset

, so 
\begin_inset Formula $\varphi^{2}=\varphi+1$
\end_inset

, or 
\begin_inset Formula $\varphi=\nicefrac{\varphi+1}{\varphi}=1+\nicefrac{1}{\varphi}$
\end_inset

, or 
\begin_inset Formula $\nicefrac{1}{\varphi}=\varphi-1$
\end_inset

.
 Notice that 
\begin_inset Formula $\psi=1-\varphi$
\end_inset

, so 
\begin_inset Formula $-\psi$
\end_inset

 and 
\begin_inset Formula $\varphi$
\end_inset

 are actually reciprocals.
\end_layout

\end_inset


\begin_inset Formula 
\[
\psi=\frac{1-\sqrt{5}}{2}\quad\textrm{and}\quad\varphi=\frac{1+\sqrt{5}}{2}.
\]

\end_inset

The second one in particular is wildly famous, as it is the 
\series bold

\begin_inset Index idx
status open

\begin_layout Plain Layout
golden ratio
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "golden ratio"
target "http://en.wikipedia.org/wiki/Golden_ratio"

\end_inset


\series default
.
 It appears in many different places in mathematics, and arguably in many
 
\begin_inset Quotes eld
\end_inset

real world
\begin_inset Quotes erd
\end_inset

 situations.
 Our Fibonacci bunnies may not seem an especially compelling 
\begin_inset Quotes eld
\end_inset

real world
\begin_inset Quotes erd
\end_inset

 situation, but this number suggests that the numbers may show up in 
\begin_inset Quotes eld
\end_inset

real world
\begin_inset Quotes erd
\end_inset

 situations, and 
\begin_inset CommandInset href
LatexCommand href
name "indeed they do"
target "https://en.wikipedia.org/wiki/Fibonacci_number#In_nature"

\end_inset

.
\end_layout

\begin_layout Standard
We return to our main problem, that of finding a closed form for the Fibonacci
 sequence.
 We first wanted to verify the Eigendecomposition Theorem.
 To build the matrices 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $\Lambda$
\end_inset

, we extract the data from 
\family typewriter
evecs
\family default
 using the bracket operator 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
[]
\end_layout

\end_inset

, then build the matrices using comprehensions.
 Make sure you understand how we build these matrices.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
Q = matrix([e[1][0] for e in evecs]).transpose()
\end_layout

\begin_layout SageInput
L = diagonal_matrix([e[0] for e in E])
\end_layout

\begin_layout SageInput
M == Q*L*Q.inverse()
\end_layout

\begin_layout SageOutput
True
\end_layout

\end_deeper
\begin_layout Standard
\noindent
So the theorem works.
 How is it useful to our aim? Remember that
\begin_inset Formula 
\[
M^{n-2}\left(\begin{array}{c}
1\\
1
\end{array}\right)=\left(\begin{array}{c}
F_{n}\\
F_{n-1}
\end{array}\right).
\]

\end_inset

By substitution, this becomes
\begin_inset Formula 
\[
M^{n-2}=\left(Q\Lambda Q^{-1}\right)^{n-2}=\underset{n-2\textrm{ times}}{\underbrace{\left(Q\Lambda Q^{-1}\right)\left(Q\Lambda Q^{-1}\right)\cdots\left(Q\Lambda Q^{-1}\right)}}.
\]

\end_inset

The associative properties allows us to rewrite this as
\begin_inset Formula 
\[
M^{n-2}=\left(Q\Lambda\right)\left(Q^{-1}Q\right)\Lambda\left(Q^{-1}Q\right)\cdots\left(Q^{-1}Q\right)\left(\Lambda Q^{-1}\right).
\]

\end_inset

This simplifies to
\begin_inset Formula 
\[
M^{n-2}=Q\Lambda^{n-1}Q^{-1}.
\]

\end_inset

What's more, it is 
\begin_inset Quotes eld
\end_inset

easy
\begin_inset Quotes erd
\end_inset

 to show that for a diagonal matrix like 
\begin_inset Formula $\Lambda$
\end_inset


\begin_inset Formula 
\[
\Lambda^{k}=\left(\begin{array}{cccc}
\lambda_{1}\\
 & \lambda_{2}\\
 &  & \ddots\\
 &  &  & \lambda_{n}
\end{array}\right)^{k}=\left(\begin{array}{cccc}
\lambda_{1}^{k}\\
 & \lambda_{2}^{k}\\
 &  & \ddots\\
 &  &  & \lambda_{n}^{k}
\end{array}\right),
\]

\end_inset

so we can write 
\begin_inset Formula $\Lambda^{k}$
\end_inset

 in a simpler form.
\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
TypeError
\end_layout

\end_inset

!
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
no canonical coercion from Symbolic Ring to Rational Field
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
Lk = diagonal_matrix([L[i,i]^n for i in xrange(L.nrows())])
\end_layout

\begin_layout SageError
TypeError: no canonical coercion from Symbolic Ring to Rational Field
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Well, 
\emph on
that's
\emph default
 odd.
 What about handing it a radical expression first?
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
Lk = diagonal_matrix([L[i,i].radical_expression()^(n-2) 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for i in xrange(L.nrows())])
\end_layout

\begin_layout SageInput
Lk
\end_layout

\begin_layout SageOutput
[(-1/2*sqrt(5) + 1/2)^(n-2)
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

0]
\end_layout

\begin_layout SageOutput
[
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

0 (1/2*sqrt(5) + 1/2)^(n-2)]
\end_layout

\end_deeper
\begin_layout Standard
\noindent
That worked.
 Sage seems to want a radical expression to proceed; we can adapt to that
 with 
\begin_inset Formula $Q$
\end_inset

, as well.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
Q = matrix([[Q[0,0].radical_expression(), 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

Q[0,1].radical_expression()], 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

[Q[1,0].radical_expression(), 
\backslash

\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

Q[1,1].radical_expression()] 
\backslash

\end_layout

\begin_layout SageMoreInput
])
\end_layout

\begin_layout SageInput
Q
\end_layout

\begin_layout SageOutput
[
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

1
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

1]
\end_layout

\begin_layout SageOutput
[-1/2*sqrt(5) - 1/2 1/2*sqrt(5) - 1/2]
\end_layout

\end_deeper
\begin_layout Standard
\noindent
We can now compute 
\begin_inset Formula $Q\Lambda^{k}Q^{-1}$
\end_inset

 directly.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
Q*Lk*Q.inverse()*matrix([[1],[1]])
\end_layout

\begin_layout SageOutput
[ 1/20*sqrt(5)*(1/2*sqrt(5) + \SpecialChar \ldots{}

\end_layout

\end_deeper
\begin_layout Standard
\noindent
\SpecialChar \ldots{}
well, it's a bit of a mess.
 In fact, all we care about is the top element, and we'd prefer to have
 it fully simplified.
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
(Q*Lk*Q.inverse()*matrix([[1],[1]]))[0,0].full_simplify()
\end_layout

\begin_layout SageOutput
1/5*sqrt(5)*((1/2*sqrt(5) + 1/2)^n - (-1/2*sqrt(5) + 1/2)^n)
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Well, 
\emph on
that's
\emph default
 convenient! This is
\begin_inset Formula 
\[
\frac{1}{5}\,\sqrt{5}\left[\left(\frac{1}{2}\,\sqrt{5}+\frac{1}{2}\right)^{n}-\left(-\frac{1}{2}\,\sqrt{5}+\frac{1}{2}\right)^{n}\right],
\]

\end_inset

so with a slight rewrite we find that
\begin_inset Formula 
\[
F_{n}=\frac{1}{\sqrt{5}}\left(\varphi^{n}-\psi^{n}\right),
\]

\end_inset

an awfully elegant closed form!
\end_layout

\begin_layout Section*
Exercises
\end_layout

\begin_layout Subsection*
True/False.
 If the statement is false, replace it with a true statement.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
1.
 A recursive algorithm to a problem is one where the algorithm invokes itself
 on a smaller case of the problem.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
2.
 A recursive algorithm should try to exploit the well-ordering property
 of the integers (
\begin_inset Formula $\mathbb{Z}$
\end_inset

).
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
3.
 The rows of Pascal's triangle appear in many places, such as in the expansion
 of trinomials.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
4.
 Because Pascal's triangle has only one recursion, there is no danger of
 encountering a 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RuntimeError
\end_layout

\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
5.
 The growth of a population of bunnies is one of the fundamental properties
 of mathematics.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
6.
 Every recursive statement can be solved using an easily-implemented function.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
7.
 If a problem can be solved by recursion, then implementing it by recursion
 is the best approach.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
8.
 A very deep recursion can indicate that something has gone awry, like an
 infinite loop.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
9.
 You can get around the delay in computing the 40th Fibonacci number by
 buying a faster computer.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
10.
 A cache is a local variable that stores the function's previous results.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
11.
 Sage provides a 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
@cached_function
\end_layout

\end_inset

 decorator that automatically caches a function's previous results.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
12.
 You can sometimes turn a recursive function into a loop, thereby avoiding
 penalties associated with recursion.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
13.
 As the golden ratio is unique to the Fibonacci numbers, they are of purely
 theoretical interest.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
14.
 Eigendecomposition allows us to rewrite a matrix 
\begin_inset Formula $M$
\end_inset

 in terms of other matrices that are themselves related to vectors that
 
\begin_inset Formula $M$
\end_inset

 rescales.
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
15.
 You can obtain a radical representation of an algebraic number using the
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.radical_simplify()
\end_layout

\end_inset

 message.
\end_layout

\begin_layout Subsection*
Multiple choice
\end_layout

\begin_layout Labeling
\labelwidthstring 99.
1.
 The well-ordering property applies to which of these sets?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 
\begin_inset Formula $\mathbb{N}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 
\begin_inset Formula $\mathbb{Z}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 
\begin_inset Formula $\mathbb{Q}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 
\begin_inset Formula $\mathbb{R}$
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
2.
 Pascal's triangle is a good example of recursion because:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 It has many applications.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 Each row can be defined in terms of the previous row.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 It is one of the fundamental problems of mathematics.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 It makes an effective critique of Descartes' philosophy of systematic doubt.
\begin_inset Foot
status open

\begin_layout Plain Layout
Gratuitous and irrelevant reference to modern philosophy included at no
 extra charge.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
3.
 The Fibonacci numbers are a good example of recursion because:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 They have many applications.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 Each number can be defined in terms of previous numbers.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 They relate to one of the fundamental problems of mathematics.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 If you can get a sequence of numbers named after you, 
\begin_inset CommandInset href
LatexCommand href
name "you have to be right --- you just have to!"
target "https://en.wikipedia.org/wiki/Mersenne_prime#History"

\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
4.
 Which proof technique is essentially a kind of recursion?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 contradiction
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 contrapositive
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 induction
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 hypothesis testing
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
5.
 What happens in Sage if you accidentally program an infinite recursion?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 the computer explodes
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 the program hangs
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RuntimeError
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
RecursionError
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
6.
 Why is it actually a bad idea to implement the Fibonacci sequence with
 a naïve recursion?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 A naïve implementation repeats the vast majority of its computations.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 Except for base cases, every recursion doubles the number of computations
 needed.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 The time required to compute the numbers grows about as fast as the numbers
 themselves.
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 All of the above.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
7.
 Which of the following alternatives to recursion do you have to work out
 by analyzing the algorithm, rather than using some combination of Sage
 commands or variables?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 caching
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 finding a closed form
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 induction
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 looping
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
8.
 Which of the following best defines the ring of algebraic numbers?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 
\begin_inset Flex Sage Constant
status open

\begin_layout Plain Layout
AA
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 the set of all roots of polynomials with integer coefficients
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 the smallest field containing the roots of polynomials with integer coefficient
s
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 the smallest field containing all the irrational numbers
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
9.
 The best command or message to turn an algebraic number into an exact,
 but easy-to-read 
\emph on
numerical
\emph default
 expression is:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.exactify()
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.full_simplify()
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.minpoly()
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.radical_expression()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.
10.
 Which of the following best describes the meaning of an eigenvector?
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 a vector that is useful for finding closed forms of sequences
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 a vector that the matrix rescales, but leaves in the same direction
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 a vector that is linearly independent of other eigenvectors
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 a vector that can be used to decompose a matrix into a computationally
 useful form
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 99.

\emph on
Bonus.

\emph default
 Given the recursive definition of a sequence of mathematical bunnies, the
 best way to find a 
\begin_inset Quotes eld
\end_inset

closed form
\begin_inset Quotes erd
\end_inset

 to describe the sequence is to
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring M.
A.
 acquire dogs
\end_layout

\begin_layout Labeling
\labelwidthstring M.
B.
 box them up
\end_layout

\begin_layout Labeling
\labelwidthstring M.
C.
 fence them in
\end_layout

\begin_layout Labeling
\labelwidthstring M.
D.
 dress them up
\end_layout

\begin_layout Labeling
\labelwidthstring M.
E.
 Enclose them in spacesuits, like Glenda:
\begin_inset Foot
status open

\begin_layout Plain Layout
Downloaded from 
\begin_inset CommandInset href
LatexCommand href
name "Bell Labs' Plan 9 website"
target "http://plan9.bell-labs.com/plan9/glenda.html"

\end_inset

 and used with permission (we think --- the wording's a tad vague)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename graphics/solving_equations_graphics/glenda.jpg
	lyxscale 10
	height 1in

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
Short answer
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
1.
 Why would 
\emph on
pascals_row
\emph default
 not have such trouble with recursion that the Fibonacci sequence did? That
 is, what difference in the pseudocode (and, therefore, the Sage code) makes
 
\emph on
pascals_row
\emph default
 more amenable to recursion than the Fibonacci sequence?
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
2.
 Would a cache be as useful for 
\emph on
pascals_row
\emph default
 as it was for the Fibonacci sequence? Why or why not?
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
3.
 Back on p.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "programming: plot x, x^2, log x, e^x and compare"

\end_inset

 we asked you to plot 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $x^{2}$
\end_inset

, 
\begin_inset Formula $\log_{10}x$
\end_inset

, and 
\begin_inset Formula $e^{x}$
\end_inset

 and rank them in order from largest to smallest.
 Recreate this graph on the interval 
\begin_inset Formula $\left[1,15\right]$
\end_inset

, adding to it a curve whose points are defined by the Fibonacci numbers
 from
\begin_inset space ~
\end_inset

1 to
\begin_inset space ~
\end_inset

15.
 Again, rank these functions according to which grows fastest.
 
\emph on
Hint:
\emph default
 Recall that the 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
line()
\end_layout

\end_inset

 function graphs a 
\begin_inset Quotes eld
\end_inset

curve
\begin_inset Quotes erd
\end_inset

 defined by a finite set of points.
 You may need to adjust 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
ymax
\end_layout

\end_inset

 in order to view the plot well.
\end_layout

\begin_layout Subsection*
Programming
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
1.
 Suppose 
\begin_inset Formula $y=x^{m}q$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 does not divide 
\begin_inset Formula $q$
\end_inset

.
 For example, if 
\begin_inset Formula $y=12$
\end_inset

 and 
\begin_inset Formula $x=2$
\end_inset

, then 
\begin_inset Formula $m=2$
\end_inset

.
 We call 
\begin_inset Formula $m$
\end_inset

 the 
\series bold
multiplicity 
\series default
of 
\begin_inset Formula $x$
\end_inset

, and can compute the it using the following recursive algorithm:
\end_layout

\begin_deeper
\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
multiplicity
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, two objects such that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x$
\end_inset

 divides 
\begin_inset Formula $y$
\end_inset


\begin_inset Quotes erd
\end_inset

 makes sense
\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
the number of times 
\begin_inset Formula $x$
\end_inset

 divides 
\begin_inset Formula $y$
\end_inset


\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $x$
\end_inset

 does not divide 
\begin_inset Formula $y$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
result
\emph default
 = 0
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\emph on
result
\emph default
 = 1 + 
\emph on
multiplicity
\emph default
(
\begin_inset Formula $\nicefrac{y}{x}$
\end_inset

)
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\emph on
result
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(a) Implement this as a Sage program.
 Check that it gives the correct results for the following:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring (iii)
(i) 
\begin_inset Formula $y=12$
\end_inset

, 
\begin_inset Formula $x=2$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring (iii)
(ii) 
\begin_inset Formula $y=12$
\end_inset

, 
\begin_inset Formula $x=3$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring (iii)
(iii) 
\begin_inset Formula $y=t$
\end_inset

, 
\begin_inset Formula $x=t^{4}+t^{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring (m)
(b) It is possible to solve this problem non-recursively, using a 
\series bold
while
\series default
 loop.
 Write pseudocode for such an algorithm, then implement it in Sage.
 Test your program on the same examples.
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 9.
2.
 Rewrite 
\emph on
pascals_row
\emph default
 so that it uses a manual cache.
 Do not use Sage's 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
@cached_function
\end_layout

\end_inset

 capability; rather, use a list where the 
\begin_inset Formula $i$
\end_inset

th entry is also a list: the 
\begin_inset Formula $i$
\end_inset

th row of Pascal's triangle.
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
3.
 We can count how complicated a function's recursion is with a global variable
 called 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
invocations
\end_layout

\end_inset

.
 We add two lines at the beginning of the recursive function that declare
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
invocations
\end_layout

\end_inset

 to be 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
global
\end_layout

\end_inset

 and then add
\begin_inset space ~
\end_inset

1 to it.
 For instance, we could do this with 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
funny_bunnies()
\end_layout

\end_inset

 as follows:
\end_layout

\begin_deeper
\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
def funny_bunnies(n):
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

global invocations
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

invocations = invocations + 1
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if n == 1 or n == 2:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = 1
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else:
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

result = funny_bunnies(n-1) + funny_bunnies(n-2)
\end_layout

\begin_layout SageMoreInput
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return result
\end_layout

\end_deeper
\begin_layout Standard
Now, every time we run it, we first set 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
invocations
\end_layout

\end_inset

 to
\begin_inset space ~
\end_inset

0, then run the program, then print 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
invocations
\end_layout

\end_inset

.
 For example:
\end_layout

\begin_layout SageInteraction

\end_layout

\begin_deeper
\begin_layout SageInput
invocations = 0
\end_layout

\begin_layout SageInput
funny_bunnies(7)
\end_layout

\begin_layout SageOutput
13
\end_layout

\begin_layout SageInput
invocations
\end_layout

\begin_layout SageOutput
25
\end_layout

\end_deeper
\begin_layout Standard
(This is not the same as the number of recursions.)
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(a) Do this for the values 
\begin_inset Formula $n=7$
\end_inset

, 8, 9, 10, and 11.
 Would you say that this sequence behaves like the Fibonacci numbers, much
 as we saw with the number of recursions? If so, find a recursive formula
 to describe the pattern in the numbers.
 If not, how would you describe it?
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(b) Modify the 
\emph on
pascals_row
\emph default
 program to compute the number of invocations, then run it for a few values
 of 
\begin_inset Formula $n$
\end_inset

.
 Is the number of invocations in this case Fibonacci-like? If so, find a
 recursive formula to describe the patter in the numbers.
 If not, how would you describe it?
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 9.
4.
 John von Neumann showed that it is possible to represent every natural
 number in terms of the symbols 
\begin_inset Formula $\left\{ \right\} $
\end_inset

 and 
\begin_inset Formula $\emptyset$
\end_inset

:
\begin_inset Formula 
\begin{align*}
0 & \leftrightarrow\emptyset\\
1 & \leftrightarrow\left\{ \emptyset\right\} \\
2 & \leftrightarrow\left\{ \emptyset,\left\{ \emptyset\right\} \right\} \\
3 & \leftrightarrow\left\{ \emptyset,\left\{ \emptyset\right\} ,\left\{ \left\{ \emptyset,\left\{ \emptyset\right\} \right\} \right\} \right\} \\
 & \vdots\\
n & \leftrightarrow\left\{ n-1,\left\{ n-1\right\} \right\} 
\end{align*}

\end_inset

As you can see from the last line especially, this is a recursive definition:
\begin_inset Formula 
\[
n=\left(n-1\right)\cup\left\{ n-1\right\} .
\]

\end_inset

Implement this as Sage code.
\emph on

\begin_inset Newline newline
\end_inset

Hint:
\emph default
 This is not hard, but you have to be careful.
 First, the recursive nature of the algorithm means the function must return
 a frozen set.
 To create a frozen set 
\begin_inset Formula $R$
\end_inset

 that contains another frozen set 
\begin_inset Formula $S$
\end_inset

, 
\emph on
as well as other elements,
\emph default
 first create 
\begin_inset Formula $R$
\end_inset

 as a mutable set (
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
R = set()
\end_layout

\end_inset

), add 
\begin_inset Formula $S$
\end_inset

 to it, add the other elements (using 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.add()
\end_layout

\end_inset

, 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
.update()
\end_layout

\end_inset

, and so forth as appropriate), and finally convert 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
R
\end_layout

\end_inset

 to a frozen set.
\end_layout

\begin_layout Labeling
\labelwidthstring 9.
5.
 Suppose you have a set of 
\begin_inset Formula $n$
\end_inset

 objects, and you want to know which subsets it has of 
\begin_inset Formula $m$
\end_inset

 elements.
\begin_inset Foot
status open

\begin_layout Plain Layout
This may seem like the sort of question only the purest of pure mathematicians
 would care about, but it's actually related to the reason you never seem
 to buy a winning ticket for PowerBall.
\end_layout

\end_inset

 The following algorithm would accomplish this for you:
\end_layout

\begin_deeper
\begin_layout Pseudocode

\series bold
algorithm
\series default
 
\emph on
combinations
\end_layout

\begin_layout Pseudocode

\series bold
inputs
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

, a set of 
\begin_inset Formula $n$
\end_inset

 objects
\end_layout

\begin_layout Itemize
\begin_inset Formula $m$
\end_inset

, the number of objects you'd like to pick from 
\begin_inset Formula $S$
\end_inset


\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
outputs
\end_layout

\begin_deeper
\begin_layout Itemize
the subsets of 
\begin_inset Formula $S$
\end_inset

 of size 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_deeper
\begin_layout Pseudocode

\series bold
do
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $\left|S\right|=m$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 
\emph on

\begin_inset Formula $\left\{ S\right\} $
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
else
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\emph on
result
\emph default
 = 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
for
\series default
 
\begin_inset Formula $s\in S$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

let 
\begin_inset Formula $U=S\backslash s$
\end_inset


\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset

add 
\emph on
combinations
\emph default
(
\emph on
U
\emph default
, 
\emph on

\begin_inset Formula $m$
\end_inset


\emph default
) to 
\emph on
result
\end_layout

\begin_layout Pseudocode
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
quad 
\end_layout

\end_inset


\series bold
return
\series default
 
\emph on
result
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(a) Implement this as a Sage program.
\begin_inset Newline newline
\end_inset


\emph on
Hint:
\emph default
 This is not hard, but you have to be careful.
 First, the recursive nature of the algorithm means it 
\emph on
result
\emph default
 must be a frozen set.
 However, creating a frozen set that contains a set 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
S
\end_layout

\end_inset

 doesn't work if you use 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
frozenset(S)
\end_layout

\end_inset

, because that creates a frozen set whose elements are the elements of 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
S
\end_layout

\end_inset

, in essence 
\emph on
converting
\emph default
 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
S
\end_layout

\end_inset

 from a mutable set to a frozen set, rather than making a frozen set whose
 one element is 
\begin_inset Flex Sage Word
status open

\begin_layout Plain Layout
S
\end_layout

\end_inset

.
 To create a frozen set whose element is another set, first create a mutable
 set, add a frozen set to it, then convert the mutable set to a frozen set.
 Essentially, the one line of the first case of the pseudocode turns into
 three lines of Sage code.
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(b) Let 
\begin_inset Formula $S=\left\{ 1,2,3,4,5,6,7,8\right\} $
\end_inset

 and evaluate the size of 
\emph on
combinations
\emph default
(
\emph on
S
\emph default
, 
\emph on
i
\emph default
) for each 
\begin_inset Formula $i=0,\ldots,8$
\end_inset

.
 The resulting sizes appear earlier in the text.
 Where?
\end_layout

\begin_layout Labeling
\labelwidthstring (m)
(c) Do you think this is a freak accident, or does it hold in general? What
 makes you say this?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
